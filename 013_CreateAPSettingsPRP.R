#rm(list=ls())

#Name:	013_CreateAPSettingsPRP.R
#Purpose:	Create a PRP file such that I can load it into the AP GUI and save time and prevent mistakes
#Author:	PA Fekety
#Date:	2017.01.10


#2017.01.10 New
#2017.01.27	Rerunning AP with Van Kane's set points. 
#		Increased tile width / height from 3000 to 21000
#2018.02.20	in writeSection1() APProcessor version upped from 1.67 to  1.75

#The PRP is a text file that holds settings for AreaProcessor.exe. I should be able
#to calculate the settings and write my own text file. Fingers crossed.


#--------------
#--------------
#Libraries
#--------------
#--------------


library(rgdal)

#LandTrendr Coordinates (i.e. EPSG 5071)
#Note, this could be entered as:  CRS("+init=epsg:5071")
Coord.LandTrendr = CRS("+init=epsg:5071")


#--------------
#--------------
#Functions
#--------------
#--------------

#Name:
#	
#Purpose:
#	
#Inputs:
#	
#Outputs:
#	


#Purpose:
#	Calculates the mid latitude of the study area. This is an input into FUSION's setup.bat
#	and is used to calculate solar radiation index (SRI).
#Inputs:
#	xMid - (num) the midpoint, in the y-direction, of the study area in AEA coordinates.
#	yMid - (num) the midpoint, in the y-direction, of the study area in AEA coordinates.
#Output:
#	the Latitude, in degrees, of the study area's midpoint
calculateLatitude <- function(xMid,yMid) {
	#determine if inputs are specified
	if (is.null(xMid)) stop("x-coordinate not specified")
	if (is.null(yMid)) stop("y-coordinate not specified")
	
	#create a spatial object for the midpoint
	midPoint.LandTrendr <- SpatialPoints(coords=cbind(xMid,yMid), proj4string=Coord.LandTrendr)
	#transform midpoint spatial object to lat long
	midPoint.LatLon <- spTransform(midPoint.LandTrendr, CRS("+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs "))
	
	#return latitude value
	return(round(midPoint.LatLon@coords[2],2))
}


#Purpose:
#	Runs FUSION's DTM describe
#Input:
#	DTMSPEC (str) - file paths to DTM
#	OutputDirectory (str) - Processing Home
#	OutputName (str) - Name of the files generated
#	ALL (logical) - Should all the DTMS be described?
#	WHICH (vector) - which DTMs should be included
#Output:
#	CSV file generated by

RunDtmDescribe <- function(DtmDirectory, OutputDirectory, OutputName, ALL=TRUE, WHICH=NULL){
	
	if(ALL){
	#find the DTMs in DtmSpec
		DtmPaths <- dir(path=DtmDirectory, full.names=TRUE, pattern="[.]dtm$")
	} else {
		DtmPaths <- vector()
		for(i in 1:length(WHICH)){
			DtmPath <- dir(path=DtmDirectory, full.names=TRUE, pattern=paste0(WHICH[i],".dtm$"))
			DtmPaths <- c(DtmPaths, DtmPath)
		}
	}
	
	#write a text file of the DTM file paths
	DtmFileTxt <- paste0(OutputDirectory, OutputName, "_filelist.txt")
	sink(file=DtmFileTxt)
	for (DtmPath in DtmPaths){
		cat(DtmPath)
		cat('\n')
	}
	sink()
	
	#Run Fusion DTMDescribe
	shell(
		paste0("c:\\FUSION\\DTMDescribe.exe ", DtmFileTxt, " ", OutputDirectory, OutputName, "_Summary.csv")
		)
}




#Name:
#	writeSection1
#Purpose:
#	Writes section 1 of the PRP; Header
#Inputs:
#	NONE
#Outputs:
#	Text for section 1
writeSection1 <- function(){
	#Section 1
	cat('[Header]')
	cat('\n')
	cat('Program=AreaProcessor')
	cat('\n')
	cat('Version=1.75000000') #Okay, I couldn't find a way to calculate / look up version number so I hard coded it in
	cat('\n')
}


#Name:
#	writeSection2
#Purpose:
#	Write section 2 of the PRP; AreaSpecificOptions
#Inputs:
#	PROJECT (char) - name of the lidar project
#	LATITUDE (int) - latitude for center of the lidar unit; default is 45 degrees
#		
#Outputs:
#	Text for section 2
writeSection2 <- function(PROJECT="", LATITUDE=45){
	#Section 2
	cat('[AreaSpecificOptions]')
	cat('\n')
	cat(paste0('AreaName=', PROJECT))
	cat('\n')
	cat('CoordinateSystem=0') 
	cat('\n')
	cat('CoordinateSystemZone=0') #Other
	cat('\n')
	cat('MeasurementUnits=0')
	cat('\n')
	cat(paste0('Latitude=', LATITUDE))
	cat('\n')
	cat('MinimumIntensity=-1')
	cat('\n')
	cat('MaximumIntensity=254')
	cat('\n')
	cat('ClassOptionString=0,1,2,3,4,5')
	cat('\n')
}


#Name:
#	writeSection3
#Purpose:
#	Write section 3 of the PRP; ProcessingOptions
#Inputs:
#	TILEHEIGHT (int) - tile height in meters; needs to be divisible by cell size
#	TILEWIDTH (int) - tile with in meters; needs to be divisible by cell size
#	CELLSIZE (num) - Cell size for output rasters
#Outputs:
#	Text for section 3
writeSection3 <- function(TILEHEIGHT, TILEWIDTH, CELLSIZE, NCORES){
	
	#Buffer, 2 times the Cell Size
	BUFFER <- 2*CELLSIZE
	 
	#Section 3
	cat('[ProcessingOptions]')
	cat('\n')
	cat(paste0('AlignmentCellSize=', CELLSIZE, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat('ForceAlignmentToGrid=1')
	cat('\n')
	cat('TileBaseName=')
	cat('\n')
	cat('TileComputeMethod=4') #This value is 1 smaller than the GUI display
	cat('\n')
	cat('UseCustomLog=1')
	cat('\n')
	cat('UseIndividualTileLogs=1')
	cat('\n')
	cat('OmitDriveLetter=0')
	cat('\n')
	cat('DeleteTiles=1')
	cat('\n')
	cat('ClipNewTiles=1')
	cat('\n')
	cat('UseFileCaching=0')
	cat('\n')
	cat('CreateIndexFiles=0')
	cat('\n')
	cat('CheckForClippedTiles=1')
	cat('\n')
	cat('UseMultipleProcesses=1')
	cat('\n')
	cat('MonitorBatchFilesSeparately=0')
	cat('\n')
	cat(paste0('TileWidth=', TILEWIDTH, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat(paste0('TileHeight=', TILEHEIGHT, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat(paste0('BufferWidth=', BUFFER, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat('MaxReturnsperTile=70000000')
	cat('\n')
	cat(paste0('NumberOfProcessingStreams=', NCORES)) #How many Cores?
	cat('\n')
}


#Name:
#	writeSection4
#Purpose:
#	Write section 4 of the PRP; BlockOptions
#Inputs:
#	BLOCKWIDTH - (int) Processing block width. A dedicated stream runs a block
#	BLOCKHEIGHT - (int) Processing block height. A dedicated stream runs a block
#Outputs:
#	Text for section 4
writeSection4 <- function(BLOCKWIDTH, BLOCKHEIGHT){

	#Not Sure what this is doing
	BLOCKADJUSTEDUSERWIDTH <- BLOCKWIDTH

	cat('[BlockOptions]')
	cat('\n')
	cat('BlockMethod=1') #0, use a single block; 1 - use width and height; 2 - use columns and rows
	cat('\n')
	cat(paste0('BlockUserWidth=', BLOCKWIDTH, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat(paste0('BlockUserHeight=', BLOCKHEIGHT, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat(paste0('BlockAdjustedUserWidth=', BLOCKADJUSTEDUSERWIDTH, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat('BlockUserColumns=5')
	cat('\n')
	cat('BlockUserRows=5')
	cat('\n')
	cat('BlockAlignToBlockSize=1') #0 - False; 1 - True
	cat('\n')
}

#Name:
#	writeSection5
#Purpose:
#	Write section 5 of the PRP; Scripts
#Inputs:
#	HOMEFOLDER (char) - Base directory for the AP processing
#	PROCESSINGHOME (char) - Directory holding processing scripts
#Outputs:
#	Text for section 5
writeSection5 <- function(HOMEFOLDER, PROCESSINGHOME){


	#Primary Batch File Name
	PRIMARY <- "APFusion"

	cat('[Scripts]')
	cat('\n')
	cat(paste0('WorkingDirName=', HOMEFOLDER, 'Products'))
	cat('\n')
	cat(paste0('PrimaryBatchFileName=', PROCESSINGHOME, PRIMARY, '.bat'))
	cat('\n')
	cat(paste0('ProcessingDirName=', PROCESSINGHOME))
	cat('\n')
	cat(paste0('StreamPreprocessBatchFileName=', PROCESSINGHOME, 'preblock.bat'))
	cat('\n')
	cat(paste0('PreprocessBatchFileName=', PROCESSINGHOME, 'Basic_setup.bat'))
	cat('\n')
	cat(paste0('ProcessingBatchFileName=', PROCESSINGHOME, 'tile.bat'))
	cat('\n')
	cat(paste0('CleanupBatchFileName=', PROCESSINGHOME, 'posttile.bat'))
	cat('\n')
	cat(paste0('StreamCleanupBatchFileName=', PROCESSINGHOME, 'postblock.bat'))
	cat('\n')
	cat('ProjectionDirName=')
	cat('\n')
	cat('CacheDirName=')
	cat('\n')
}








#Name:
#	writeSection6
#Purpose:
#	Write section 6 of the PRP; PointData
#Inputs:
#	DIR_LIDAR (str) - a file path to the lidar LAS files
#Outputs:
#	Text for section 6
#	A list tracking the min and max coordinates of the lidar returns; note these values are extracted from the header
writeSection6 <- function(DIR_LIDAR){
	
	#file path for lidar files
	LAS_FILES <- dir(DIR_LIDAR, pattern="[.]laz$", full.names=TRUE)
	
	#Need to keep track of the minimum and maximum x and y-values for writeSection11()
	xMinPoints <- 1000000000
	xMaxPoints <- 0
	yMinPoints <- 1000000000
	yMaxPoints <- 0
	
	cat('[PointData]')
	cat('\n')
	cat(paste0('ObjectCount=', length(LAS_FILES)))
	cat('\n')
	for(i in 1:length(LAS_FILES)){
		#the key to reading a header. this is from the APRS website
		hd <- publicHeaderDescription()
		#creates a blank header
		pheader <- vector("list", nrow(hd))
		#assigns names to the list
		names(pheader) <- hd$Item
		#Opens a connection to the LAS file
		con <- file(LAS_FILES[i], open = "rb")
		#check to see if the file is a lasfile
		isLASFbytes <- readBin(con, "raw", size = 1, n = 4, endian = "little")
			pheader[[hd$Item[1]]] <- readBin(isLASFbytes, "character", size = 4, endian = "little")
		if (!pheader[[hd$Item[1]]] == "LASF") {
			stop("The LASfile input is not a valid LAS file")
		}
		for (j in 2:nrow(hd)) {
			pheader[[hd$Item[j]]] <- readBin(con, what = hd$what[j], 
				size = hd$Rsize[j], endian = "little", n = hd$n[j])
		}
		#close the connection
		close(con)

		#look up min, max, and number of points		
		xMin <- pheader$'Min X'
		xMax <- pheader$'Max X'
		yMin <- pheader$'Min Y'
		yMax <- pheader$'Max Y'
		zMin <- pheader$'Min Z'
		zMax <- pheader$'Max Z'
		nPoints <- pheader$'Number of point records'
		
		#update min and max x and y values
		xMinPoints <- ifelse(xMin < xMinPoints, xMin, xMinPoints)
		xMaxPoints <- ifelse(xMax > xMaxPoints, xMax, xMaxPoints)
		yMinPoints <- ifelse(yMin < yMinPoints, yMin, yMinPoints)
		yMaxPoints <- ifelse(yMax > yMaxPoints, yMax, yMaxPoints)
		
		#Build the string
		cat(paste0('Object_', i, '=1,1,', xMin, ',', yMin, ',', zMin, ',', xMax, ',', yMax, ',', zMax, ',' , nPoints, ',' , LAS_FILES[i]))
		cat('\n')
	}
	#Return the min and max x and y's
	return(list(xMinPoints=xMinPoints, 
		xMaxPoints=xMaxPoints,
		yMinPoints=yMinPoints,
		yMaxPoints=yMaxPoints))

}



#Name:
#	writeSection7
#Purpose:
#	Write section 7 of the PRP; GroundData
#Inputs:
#	PROCESSINGHOME (str) - file path 
#Outputs:
#	Text for section 7
writeSection7 <- function(PROCESSINGHOME){
	#Read in the CSV created with RunDtmDescribe()
	DtmDescribe <- read.csv(file=paste0(PROCESSINGHOME, "DTM_Ground_Summary.csv" ), as.is=TRUE)
	
	#Number of ground DTMs
	OBJECTCOUNT <- nrow(DtmDescribe)
	
	cat('[GroundData]')
	cat('\n')
	cat(paste0('ObjectCount=', OBJECTCOUNT))
	cat('\n')
	
	for( i in 1:OBJECTCOUNT){
		ORIGIN_X <- DtmDescribe[i,"Origin.X"]
		ORIGIN_Y <- DtmDescribe[i,"Origin.Y"]
		MIN_VAL <- DtmDescribe[i,"Min.data.value"]
		UPPER_RIGHT_X <- DtmDescribe[i,"Upper.right.X"]
		UPPER_RIGHT_Y <- DtmDescribe[i,"Upper.right.Y"]
		MAX_VAL <- DtmDescribe[i,"Max.data.value"]
		PATH  <- DtmDescribe[i,"File.name"]
	
		cat(paste0("Object_", i, "=1,1,", ORIGIN_X, "," , ORIGIN_Y, ",", MIN_VAL, ",", UPPER_RIGHT_X, ",", UPPER_RIGHT_Y, ",", MAX_VAL, ",1,", PATH))
		cat('\n')
	}	
}


#Name:
#	writeSection8
#Purpose:
#	Write section8  of the PRP; DensityData
#Inputs:
#	PRODUCTHOME (str) - file path
#	PROCESSINGHOME (str) - file path
#	
#Outputs:
#	Text for section 8
writeSection8 <- function(PRODUCTHOME, PROCESSINGHOME){
	#Run DtmDescribe on the density DTM
	RunDtmDescribe(DtmDirectory=paste0(PRODUCTHOME, "QAQC\\"), OutputDirectory=PROCESSINGHOME, OutputName="DTM_Density", ALL=FALSE, WHICH="QAQC_return_count")
	#Read in the CSV created with RunDtmDescribe()
	DtmDescribe <- read.csv(file=paste0(PROCESSINGHOME, "DTM_Density_Summary.csv" ), as.is=TRUE)
	
	#Number of density DTMs
	OBJECTCOUNT <- nrow(DtmDescribe)

	cat('[DensityData]')
	cat('\n')
	cat('ObjectCount=1')
	cat('\n')

	for( i in 1:OBJECTCOUNT){
		ORIGIN_X <- DtmDescribe[i,"Origin.X"]
		ORIGIN_Y <- DtmDescribe[i,"Origin.Y"]
		MIN_VAL <- DtmDescribe[i,"Min.data.value"]
		UPPER_RIGHT_X <- DtmDescribe[i,"Upper.right.X"]
		UPPER_RIGHT_Y <- DtmDescribe[i,"Upper.right.Y"]
		MAX_VAL <- DtmDescribe[i,"Max.data.value"]
		PATH  <- DtmDescribe[i,"File.name"]
	
		cat(paste0("Object_", i, "=1,1,", ORIGIN_X, "," , ORIGIN_Y, ",", MIN_VAL, ",", UPPER_RIGHT_X, ",", UPPER_RIGHT_Y, ",", MAX_VAL, ",1,", PATH))
		cat('\n')
	}
}



#Name:
#	writeSection9
#Purpose:
#	Write section 9 of the PRP; MaskLayers
#Inputs:
#	NONE
#Outputs:
#	Text for section 9
writeSection9 <- function(){
	cat('[MaskLayers]')
	cat('\n')
	cat('ObjectCount=0')
	cat('\n')
}


#Name:
#	writeSection10
#Purpose:
#	Write section 10 of the PRP; ProcessingBlocks
#Inputs:
#	NBLOCKSHIGH (int) - 
#	NBLOCKSWIDE (int) - 
#	BLOCKHEIGHT (int) - 
#	BLOCKWIDTH (int) - 
#	CELLSIZE (num) - Cell size for output rasters
#	DTMDESCRIBE
#	
#Outputs:
#	Text for section 10
writeSection10 <- function(NBLOCKSHIGH, NBLOCKSWIDE, BLOCKHEIGHT, BLOCKWIDTH, CELLSIZE,  DTMDESCRIBE){
	#Number of blocks
	nBlocks <- NBLOCKSHIGH * NBLOCKSWIDE

	xMin <- min(DTMDESCRIBE$Origin.X)
	xMax <- max(DTMDESCRIBE$Upper.right.X)
	yMin <- min(DTMDESCRIBE$Origin.Y)
	yMax <- max(DTMDESCRIBE$Upper.right.Y)
	
	#Shift cell origin to match LandTrendr
	xMin <- xMin - xMin%%CELLSIZE - CELLSIZE
	yMin <- yMin - yMin%%CELLSIZE - CELLSIZE

	cat('[ProcessingBlocks]')
	cat('\n')
	cat(paste0('ObjectCount=', nBlocks))
	cat('\n')

	i=1
	xMinBlock <- xMin
	xMaxBlock <- xMin + BLOCKWIDTH

	for( blockInX in 1:NBLOCKSWIDE){
		yMinBlock <- yMin
		yMaxBlock <- yMin + BLOCKHEIGHT
		for( blockInY in 1:NBLOCKSHIGH){
			OBJECT <- paste0("Object_", i)

			BLOCKID <- i
			BLOCKNAME <- paste0("BLOCK",i)
			cat(paste0(OBJECT, "=1,", xMinBlock, "," , yMinBlock, ",", xMaxBlock, ",", yMaxBlock, ",", BLOCKID, ",", BLOCKNAME))
			cat('\n')

			yMinBlock <- yMinBlock + BLOCKHEIGHT
			yMaxBlock <- yMaxBlock + BLOCKHEIGHT

			i <- i + 1
		}
		xMinBlock <- xMinBlock + BLOCKWIDTH
		xMaxBlock <- xMaxBlock + BLOCKWIDTH

	}
}



#Name:
#	writeSection11
#Purpose:
#	Write section 11 of the PRP; ProcessingExtent
#Inputs:
#	DTMDESCRIBE
#	LIDARPOINTS
#	CELLSIZE (num) - Cell size for output rasters
#Outputs:
#	Text for section 11
writeSection11 <- function(LIDARPOINTS, CELLSIZE){
	#Lidar Return min and max (from writeSection6())
	xMinPoints <- LIDARPOINTS$xMinPoints
	xMaxPoints <- LIDARPOINTS$xMaxPoints
	yMinPoints <- LIDARPOINTS$yMinPoints
	yMaxPoints <- LIDARPOINTS$yMaxPoints
	
	
	xMinUser <- xMinPoints - xMinPoints %% CELLSIZE - CELLSIZE
	xMaxUser <- xMaxPoints - xMaxPoints %% CELLSIZE + CELLSIZE
	yMinUser <- yMinPoints - yMinPoints %% CELLSIZE - CELLSIZE
	yMaxUser <- yMaxPoints - yMaxPoints %% CELLSIZE + CELLSIZE


	cat('[ProcessingExtent]')
	cat('\n')
	cat('HaveUserExtent=1')
	cat('\n')
	cat(paste0('UserMinX=', xMinUser))
	cat('\n')
	cat(paste0('UserMinY=', yMinUser))
	cat('\n')
	cat(paste0('UserMaxX=', xMaxUser))
	cat('\n')
	cat(paste0('UserMaxY=', yMaxUser))
	cat('\n')
	cat(paste0('OverallMinX=', xMinPoints))
	cat('\n')
	cat(paste0('OverallMinY=', yMinPoints))
	cat('\n')
	cat(paste0('OverallMaxX=', xMaxPoints))
	cat('\n')
	cat(paste0('OverallMaxY=', yMaxPoints))
	cat('\n')
	cat(paste0('AdjustedOverallMinX=', xMinUser))
	cat('\n')
	cat(paste0('AdjustedOverallMinY=', yMinUser))
	cat('\n')
	cat(paste0('AdjustedOverallMaxX=', xMaxUser))
	cat('\n')
	cat(paste0('AdjustedOverallMaxY=', yMaxUser))
	cat('\n')
	cat(paste0('AdjustedUserMinX=', xMinUser))
	cat('\n')
	cat(paste0('AdjustedUserMinY=', yMinUser))
	cat('\n')
	cat(paste0('AdjustedUserMaxX=', xMaxUser))
	cat('\n')
	cat(paste0('AdjustedUserMaxY=', yMaxUser))
	cat('\n')
}


#Name:
#	publicHeaderDescription 
#Purpose:
#	creates a header description for LAS files.
#	I found the code here:https://github.com/themel
#		Thomas Themel github@themel.com
#Inputs:
#	NULL
#Outputs:
#	a list that will store pblic header info for a LAS file.
publicHeaderDescription <- function() {
  hd <- structure(list(Item = c("File Signature (\"LASF\")",
                                "(1.1) File Source ID", "(1.1) Global Encoding",
                                "(1.1) Project ID - GUID data 1", "(1.1) Project ID - GUID data 2",
                                "(1.1) Project ID - GUID data 3", "(1.1) Project ID - GUID data 4",
                                "Version Major", "Version Minor", "(1.1) System Identifier",
                                "Generating Software", "(1.1) File Creation Day of Year",
                                "(1.1) File Creation Year", "Header Size", "Offset to point data",
                                "Number of variable length records",
                                "Point Data Format ID (0-99 for spec)", "Point Data Record Length",
                                "Number of point records", "Number of points by return",
                                "X scale factor", "Y scale factor", "Z scale factor", "X offset",
                                "Y offset", "Z offset", "Max X", "Min X", "Max Y", "Min Y", "Max Z",
                                "Min Z"), 
							Format = c("char[4]", "unsigned short", "unsigned short",
                                       "unsigned long", "unsigned short", "unsigned short",
                                       "unsigned char[8]", "unsigned char", "unsigned char", "char[32]",
                                       "char[32]", "unsigned short", "unsigned short", "unsigned short",
                                       "unsigned long", "unsigned long", "unsigned char", "unsigned short",
                                       "unsigned long", "unsigned long[5]", "double", "double", "double",
                                       "double", "double", "double", "double", "double", "double", "double",
                                       "double", "double"), 
							Size = c("4 bytes", "2 bytes", "2 bytes",
                                     "4 bytes", "2 byte", "2 byte", "8 bytes", "1 byte", "1 byte",
                                     "32 bytes", "32 bytes", "2 bytes", "2 bytes", "2 bytes", "4 bytes",
                                     "4 bytes", "1 byte", "2 bytes", "4 bytes", "20 bytes", "8 bytes",
                                     "8 bytes", "8 bytes", "8 bytes", "8 bytes", "8 bytes", "8 bytes",
                                     "8 bytes", "8 bytes", "8 bytes", "8 bytes", "8 bytes"), 
							Required = c("*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*",
                                         "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*",
                                         "*", "*", "*", "*", "*")), 
							.Names = c("Item", "Format", "Size", "Required"), 
							row.names = 2:33, 
							class = "data.frame")
  hd$what <- ""
  hd$what[grep("unsigned", hd$Format)] <- "integer"
  hd$what[grep("char", hd$Format)] <- "raw"	#this isn't quite right
  hd$what[grep("short", hd$Format)] <- "integer"
  hd$what[grep("long", hd$Format)] <- "integer"
  hd$what[grep("double", hd$Format)] <- "numeric"
  hd$signed <- TRUE
  hd$signed[grep("unsigned", hd$Format)] <- FALSE
  ## number of values in record
  hd$n <- as.numeric(gsub("[[:alpha:][:punct:]]", "", hd$Format))
  hd$n[hd$what == "character"] <- 1
  hd$n[is.na(hd$n)] <- 1
  ## size of record
  hd$Hsize <- as.numeric(gsub("[[:alpha:]]", "", hd$Size))
  ## size of each value in record
  hd$Rsize <- hd$Hsize / hd$n
  hd$Rsize[hd$what == "raw"] <- 1
  hd$n[hd$what == "raw"] <- hd$Hsize[hd$what == "raw"]
  hd
}


#Name:
#	writePRP
#Purpose:
#	Writes the PRP FUSION AP setup file
#Inputs:
#	NULL
#Outputs:
#	a list that will store pblic header info for a LAS file.
writePRP <- function(PROJECT, LATITUDE, HOMEFOLDER, PROCESSINGHOME, 
				PRODUCTHOME, DIR_LIDAR, tileWidth, tileHeight, blockWidth, blockHeight, 
				nBlocksHigh, nBlocksWide, DtmDescribe){
	#PRP file that will be written
	sink(paste0(DIR_PRP, PROJECT, "_APSetup.prp"))

	#header
	writeSection1()
	
	#Area Specific Options
	writeSection2(PROJECT=PROJECT, LATITUDE=LATITUDE)
	
	#Processing options
	writeSection3(TILEHEIGHT=tileHeight, TILEWIDTH=tileWidth, CELLSIZE=CELLSIZE, NCORES=NCORES)
	
	#Block Options
	writeSection4(BLOCKWIDTH=blockWidth, BLOCKHEIGHT=blockHeight)
	
	#Scripts
	writeSection5(HOMEFOLDER=HOMEFOLDER, PROCESSINGHOME=PROCESSINGHOME)
	
	#Point data
	lidarPoints <- writeSection6(DIR_LIDAR=DIR_LIDAR)
	
	#Ground data
	writeSection7(PROCESSINGHOME=PROCESSINGHOME)
	
	#Density data
	writeSection8(PRODUCTHOME=PRODUCTHOME, PROCESSINGHOME=PROCESSINGHOME)
	
	#Mask Layers
	writeSection9()
		
	#Processing Blocks
	writeSection10(NBLOCKSHIGH=nBlocksHigh, NBLOCKSWIDE=nBlocksWide, BLOCKHEIGHT=blockHeight, BLOCKWIDTH=blockWidth, CELLSIZE=CELLSIZE,  DTMDESCRIBE=DtmDescribe)
	
	#Processing Extent
	writeSection11(LIDARPOINTS=lidarPoints, CELLSIZE=CELLSIZE)
	
	#Close diversion
	sink()
}


#Name:
#	createPRP 
#Purpose:
#	Creates the PRP FUSION AP setup file
#	This is the main function
#Inputs:
#	studyArea
#	cellSize (num)
#	nCores (int)
#Outputs:
#	The PRP file for the AP setup file
createPRP <- function(studyArea, cellSize, nCores, DIR_BASE, DIR_LIDAR){
	
	print(paste0("Creating ground DTM for ", studyArea));flush.console()	
	
	#Directory where the LAS files are stored
	#DIR_LIDAR=paste0("D:\\Patrick\\CMS\\LidarData\\epsg5071\\", studyArea, "\\")
	
	
	#These folders are following the LTK naming scheme from setup.bat
	HOMEFOLDER <- paste0(DIR_BASE, studyArea, '\\')
	PROCESSINGHOME <- paste0(HOMEFOLDER, 'Processing\\AP\\')
	DTMSPEC <-  paste0(HOMEFOLDER, 'Deliverables\\DTM\\')
	PRODUCTHOME <- paste0(HOMEFOLDER, "Products\\")

	#Run RunDtmDescribe for the ground DTMs. This is used in a few places
	RunDtmDescribe(DtmDirectory=DTMSPEC, OutputDirectory=PROCESSINGHOME, OutputName="DTM_Ground")
	
	#Read in the CSV created with RunDtmDescribe()
	DtmDescribe <- read.csv(file=paste0(PROCESSINGHOME, "DTM_Ground_Summary.csv" ), as.is=TRUE)
	
	
	##- Find Latitude from DtmDescribe
	xMid <- mean(max(DtmDescribe$"Upper.right.X"), min(DtmDescribe$"Origin.X"))
	yMid <- mean(max(DtmDescribe$"Upper.right.Y"), min(DtmDescribe$"Origin.Y"))
	#Translate the xCoordinate
	xMid_Trans <- xMid - 3000000
	
	latitude <- calculateLatitude(xMid=xMid_Trans, yMid=yMid) 
	
	
	##------------
	# Find optimal (?) block sizes
	##------------
	#Note: I struggled on this one a little. It is a tough balance between using all the
	# cores available for processing, having a ridiculus number of processing blocks, 
	# and not having a lot of "NoData" space in the final rasters.
	# I chose to limit the NoData space. 
	
	#min and max values for the grid metrics
	cellMinX <- min(DtmDescribe$"Origin.X") - min(DtmDescribe$"Origin.X") %% cellSize
	cellMinY <- min(DtmDescribe$"Origin.Y") - min(DtmDescribe$"Origin.Y") %% cellSize
	
	cellMaxX <- max(DtmDescribe$"Upper.right.X") - max(DtmDescribe$"Upper.right.X") %% cellSize + cellSize
	cellMaxY <- max(DtmDescribe$"Upper.right.Y") - max(DtmDescribe$"Upper.right.Y") %% cellSize + cellSize
	
	
	blockRangeX <- cellMaxX - cellMinX + 2*cellSize #Add a little buffer on each side of the block
	blockRangeY <- cellMaxY - cellMinY + 2*cellSize #Add a little buffer on each side of the block
	
	#blockWidth <- ifelse( (cellSize*100-blockRangeX%%(cellSize*100) < cellSize*50), cellSize*100, cellSize*50) 
	#blockHeight <- ifelse( (cellSize*100-blockRangeY%%(cellSize*100) < cellSize*50), cellSize*100, cellSize*50) 
	#Just make it 3000 meters...
	blockWidth <- cellSize*100
	blockHeight <- cellSize*100
	
	
	#2017.01.27	Change tileWidth from 3000 to 21000
	tileWidth <- 21000
	tileHeight <- 21000
	
	#calculate how many blocks are needed in the X direction
	
	#long east to west unit
	if(((blockRangeX / blockRangeY) > 6) & (blockRangeY < 100*cellSize)){
		nBlocksHigh <- 1 
		nBlocksWide <- ifelse(ceiling(blockRangeX/ blockWidth) > 2, ceiling(blockRangeX/ blockWidth), 2)
	} else {
		#long north to south unit
		if(((blockRangeY / blockRangeX) > 6) & (blockRangeX < 100*cellSize)){
			nBlocksHigh <- ifelse(ceiling(blockRangeY / blockHeight) > 2, ceiling(blockRangeY / blockHeight), 2)
			nBlocksWide <- 1
		} else {
			#calculate how many blocks are needed in the X direction
			nBlocksWide <- ifelse(ceiling(blockRangeX/ blockWidth) > 2, ceiling(blockRangeX/ blockWidth), 2)
			#calculate how many blocks are needed in the Y direction
			nBlocksHigh <- ifelse(ceiling(blockRangeY / blockHeight) > 2, ceiling(blockRangeY / blockHeight), 2)
		}
	}
	
	#What about scenarios when less than 6 cores are being used? 
	if(nBlocksWide*nBlocksHigh < NCORES){
		#Find different block sizes, etc...
	}
	
	#Writes the PRP file
	writePRP(PROJECT=studyArea, LATITUDE=latitude, 
		HOMEFOLDER=HOMEFOLDER, PROCESSINGHOME=PROCESSINGHOME,
		PRODUCTHOME=PRODUCTHOME, DIR_LIDAR=DIR_LIDAR,
		tileWidth=tileWidth, tileHeight=tileHeight, 
		blockWidth=blockWidth, blockHeight=blockHeight, 
		nBlocksHigh=nBlocksHigh, nBlocksWide=nBlocksWide,
		DtmDescribe=DtmDescribe)
	
}



#--------------
#--------------
#Create the PRP
#--------------
#--------------

#studyArea="PREF2011"
#cellSize=30

#nCores=6
#DIR_BASE= "D:\\Patrick\\CMS\\LidarMetrics\\epsg5071_Trans\\FusionAP\\"
#createPRP(studyArea=studyArea, cellSize=CELLSIZE, nCores=NCORES, DIR_BASE=DIR_BASE)


